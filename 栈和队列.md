# 3.1 栈
* 定义：限定仅在表尾进行插入或者删除操作的线性表。表尾称为栈顶，表头称为栈底。栈通过后进先出的原则进行修改。
## 3.1.1 顺序栈
* 定义：利用一组地址连续的存储单元，依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。
```
/*顺序栈类型定义*/ 
typedef int SElemType_Sq;  //栈元素的类型定义
typedef struct
{
	SElemType_Sq *base;  //栈底指针， 
	SElemType_Sq *top;   //栈顶指针
	int stacksize;
}SqStack;
```
* 一些基本的操作，看rec中的代码
```
//1.初始化栈，构造空栈 
int InitStack_Sq(SqStack *S)
{
	(*S).base=(SElemType_Sq *)malloc(STACK_INIT_SIZE*sizeof(SElemType_Sq));//申请初始化内存空间大小，得到栈底指针
	if(!(*S).base)
		exit(-1);
	(*S).top=(*S).base;
	(*S).stacksize=STACK_INIT_SIZE; 
	return 1;
}
//2.销毁栈 
int DestroyStack_Sq(SqStack *S)
{
	free((*S).base);
	(*S).base=(*S).top=NULL;
	(*S).stacksize=0;
	return 1;
}
//3.置空 
int ClearStack_Sq(SqStack *S)
{
	(*S).top=(*S).base;
	return 1;
} 
//4.判空 
int StackEmpty_Sq(SqStack S)
{
	if(S.top==S.base)
		return 1;
	else
		return 0;
}
//5.求栈长 
int StackLength_Sq(SqStack S)
{
	return S.top-S.base;	
}
//6.获取栈顶元素 
int GetTop_Sq(SqStack S, SElemType_Sq *e)
{
	if(S.base==S.top)
		return 0;
	*e=*(S.top-1);
	return 1;	
}
//7.元素e进栈 
int Push_Sq(SqStack *S, SElemType_Sq e)
{
	if((*S).top-(*S).base >= (*S).stacksize)//栈的长度满了，需要扩充 
	{
		(*S).base=(SElemType_Sq *)realloc((*S).base,((*S).stacksize+STACKINCREMENT)*sizeof(SElemType_Sq));
		if(!(*S).base)
			exit(-1);
		(*S).top=(*S).base+(*S).stacksize;
		(*S).stacksize+=STACKINCREMENT;	
	}
	*(S->top)=e;  //进栈先赋值，然后自增。 
	(S->top)++;
	return 1;	
}
//8.元素e出栈 
int Pop_Sq(SqStack *S, SElemType_Sq *e)
{
	if((*S).top==(*S).base)
		return 0;
	(*S).top--;
	*e=*((*S).top);
	return 1;
} 
//9.遍历全栈 
int StackTraverse_Sq(SqStack S, void(Visit)(SElemType_Sq))
{
	SElemType_Sq *p=S.base;
	while(p<S.top)
	{
		Visit(*p++);	
	}
	return 1;
} 
```
## 3.1.2 栈的应用
* 进制转换:N=(N div d) * d+N mod d (其中div是整除，mod是取余)，最终计算过程是从低位到高位产生八进制的各个数位。而输出打印则恰恰相反，正好是一个进栈和出栈的过程。
```
void conversion(int i)
{
	SqStack S;
	SElemType_Sq e;
	InitStack_Sq(&S);
	printf("十进制数%d转换为八进制后为：0",i);
	while(i)
	{
		Push_Sq(&S,i%8);  //进栈时从低位到高位； 
		i=i/8;
	}
	while(!StackEmpty_Sq(S))
	{
		Pop_Sq(&S,&e);
		printf("%d",e);
	}
} 
```
* 行编辑程序：接受用户从终端输入的程序或数据，并存入用户的数据区，其做法是设立一个输入缓存区，用以接受用户输入的一行字符，然后逐行存入用户数据区，允许用户出错，并发现有误时可以及时更正。例如当用户发现刚刚键入的一个字符是错的时，可以补进一个退格符“#”来表示当前字符无效，若发现当前键入的行内差错较多，可以键入一个退行符“@”，表示当前行中字符均无效；因此，可设置该缓存区为一个栈结构，每当终端接受了一个字符之后，先做如下判别，如果它既不是退格符也不是退行符，则将该字符压入栈顶，若是一个退格符，则从栈顶删去一个字符，若是退行符，则将字符栈清空。
```
void LineEdit(char Buffer[])
{
	SqStack S;
	SElemType_Sq e;
	int i;
	char ch;
	
	InitStack_Sq(&S);
	i=0;
	ch=Buffer[i++];
	while(ch!='\0')
	{
		while(ch!='\0'  && ch!='\n')
		{
			switch(ch)
			{
				case '#':Pop_Sq(&S,&e);
					break;
				case '@':ClearStack_Sq(&S);
					break;
				default:Push_Sq(&S,ch);
			}
			ch=Buffer[i++];	
		}
		if(ch=='\n')
		{
			Push_Sq(&S,ch);
			StackTraverse_Sq(S,Print);
			ClearStack_Sq(&S);
			ch=Buffer[i++];	
		}	
	}
	if(ch=='\0')
	{
		StackTraverse_Sq(S,Print);
		DestroyStack_Sq(&S);	
	}
}
```








