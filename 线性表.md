# 2.线性表
在数据元素的非空有限集中
* 存在唯一的称为“第一个”的数据元素
* 存在唯一的称为“最后一个”的数据元素
* 除第一个之外，集合中的每一个数据元素均只有一个前驱
* 除最后一个之外，集合的每一个元素均只有一个后继。
## 2.1 线性表的类型表示
* 将线性表记为（a1,...a(i-1),ai,a(i+1),...,an）,其中ai-1领先于ai，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。
* 线性表中元素的个数定义为线性表的长度,n=0时为空表，非空表中的数据元素的位置固定。
* 线性表的长度可以增长和缩短，对表中元素可以访问、插入和删除
## 2.2 线性表的顺序表示和实现
* 顺序表示是指用一组地址连续的存储单元依次存储线性表的数据元素
* 顺序存储结构是一种随机存取的存储模式，只要确定了存储线性表的起始位置，表中的任意数据元素都可以随机存取，不必考虑存储位置，而且存储位置存在着线性关系。
### 线性表的存储结构
```
/* 宏定义 */

#define LIST_INIT_SIZE 100  //线性表存储结构的初始分配量 
#define LISTINCREMENT 10  //分配增量
typedef int LElemType_Sq;

/* 顺序表类型定义 */

typedef  struct
{
	LElemType_Sq *elem;//存储空间的基址，指向第一个结点的指针
	int length;//当前线性表的长度
	int listsize;//当前分配的存储容量	
} SqList;
```
* 以上利用结构体定义了一个顺序表，其中elem指向线性表的基地址。

### 实现基本操作的各种函数
* 初始化函数：先要为顺序表分配一个预定大小的内存空间，而且将length设置为0；
```
//1.初始化操作：为顺序表分配一个预定义大小的数组空间，并将长度设为0； 
int InitList_Sq(SqList *L)   //参数为传入的线性表的首地址 
{
	(*L).elem=(LElemType_Sq *)malloc(sizeof(LElemType_Sq)*LIST_INIT_SIZE);//为顺序表分配空间
	if(!(*L).elem) 
		exit(-1);
	(*L).length=0;//初始化空表长度
	(*L).listsize=100;
	return 0; 
} 
```
* 线性表的插入操作：若下标从0开始，则表中第i个元素为L.elem[i-1]，插入操作即在第i-1和第i个元素之间插入一个元素。首先需要确定插入之后是否会引起内存不够，然后进行内存扩容；之后需要先将i-1之后的元素向后移一位，然后将待插入的元素放入i位置。
```
//10.顺序表中插入一个元素 
int ListInsert_Sq(SqList *L, int i, LElemType_Sq e)
{
	//首先需要判断插入之后表的内存是否够用，若不够用需申请足够的内存
	LElemType_Sq * newbase; 
	if(i<1 || i>(*L).length+1)
		return -1;
	if((*L).length>=(*L).listsize)
	{
		newbase=(LElemType_Sq *)realloc((*L).elem,sizeof(LElemType_Sq)*(LISTINCREMENT+(*L).listsize));
		if(!newbase)
			exit(-1);
		(*L).elem=newbase;
		(*L).listsize+= LISTINCREMENT;
	}
	//开始插入数据元素，需要先把i后面的元素都向后移动一位，然后把e的值赋给当前i位置
	 LElemType_Sq *q;
	 q=&(*L).elem[i-1];//得到待插入位置
     LElemType_Sq *p;  
	for(p=&(*L).elem[(*L).length-1];p>=q;p--)
		*(p+1)=*p;//待插入位置后的元素后移
	*q=e;
	(*L).length++;
	return 0; 
}
```
* 线性表的删除操作：先找到待删除的元素i的位置，然后将i之后的元素向左移一位
```
//11.顺序表删除元素 
int ListDelete_Sq(SqList *L, int i, LElemType_Sq *e)
{
	if(i<1 || i>(*L).length)
		return -1;
	LElemType_Sq *q;
 	q=&(*L).elem[i-1];//得到待插入位置
 	*e=*q;
 	LElemType_Sq *p;
 	p=(*L).elem+(*L).length+1;
 	for(q++;q<=p;q++)
 	{
		*(q-1)=*q; 	
 	}
 	(*L).length--;
 	return 0;
}
```
* 顺序表的合并：将两个顺序表按升序进行合并，变成另外一个链表；一种是利用基本操作函数，另一种利用指针。
* 利用基本操作：同时遍历两个表，得到他们的交集中元素的排列，每得到一个最小值就插入到新表中，直到都插完.(感觉这种方法还是有点问题)
```
void MergeSqList_1(SqList La, SqList Lb, SqList *Lc)
{
	int i,j;
	i=j=1;
	int k=0;
	int len_La,len_Lb;
	LElemType_Sq ai,bj;
	
	InitList_Sq(Lc);
	len_La=ListLength_Sq(La);
	len_Lb=ListLength_Sq(Lb);
	while(i<=len_La && j<=len_Lb)  //扫描La Lb表，扫描完小长度的那个 
	{
		GetElem_Sq(La,i,&ai);  //得到当前表中位置的元素 
		GetElem_Sq(Lb,j,&bj);
		if(ai<=bj)//在当前位置里，若La<Lb，在Lc表中存放La的元素。 
		{
			ListInsert_Sq(Lc,++k,ai);
			i++;//对应的La的位置向前一步			
		}

		else
		{
			ListInsert_Sq(Lc,++k,bj);
			j++;			
		}
	}
	while(i<=len_La)
	{
		GetElem_Sq(La,i++,&ai);
		ListInsert_Sq(Lc,++k,ai);
	}
	
	while(j<=len_Lb)
	{
		GetElem_Sq(Lb,j++,&bj);
		ListInsert_Sq(Lc,++k,bj);
	}	
} 
```
* 利用指针。得到两个表的首地址和尾地址。然后进行循环，最终插入新表。
```
void MergeSqList_2(SqList La, SqList Lb, SqList *Lc)
{
	LElemType_Sq *pa, *pb, *pc;
	LElemType_Sq *pa_last, *pb_last;
		
	pa = La.elem;						//指向La第一个元素 
	pb = Lb.elem;						//指向Lb第一个元素
	
										//不用InitList_Sq创建Lc 
	(*Lc).listsize = (*Lc).length = La.length + Lb.length;
	pc = (*Lc).elem = (LElemType_Sq *)malloc((*Lc).listsize*sizeof(LElemType_Sq));
	if(!pc) 
		exit(OVERFLOW);
	
	pa_last = La.elem + La.length - 1;	//指向La最后一个元素
	pb_last = Lb.elem + Lb.length - 1;	//指向Lb最后一个元素
	
	while(pa<=pa_last && pb<=pb_last) 	//La和Lb均未扫描完 
	{
		if(*pa <= *pb)
			*pc++ = *pa++;
		else
			*pc++ = *pb++;
	}
	
	while(pa <= pa_last)				//表La未扫描完 
		*pc++ = *pa++;					//插入La的剩余元素

	while(pb <= pb_last)				//表Lb未扫描完
		*pc++ = *pb++;					//插入Lb的剩余元素
}
```

## 2.3 线性表的链式表示和实现
* 定义：用一组任意存储单元存储线性表的数据元素，存储单元可以连续，也可以不连续。对数据元素来说，除了存储本身的信息之外，还需要存储一个指示其后继的信息。即包括两个域：数据域和指针域。每个结点中只包含了一个指针域，又称单链表。







