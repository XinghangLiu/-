# 2.线性表
在数据元素的非空有限集中
* 存在唯一的称为“第一个”的数据元素
* 存在唯一的称为“最后一个”的数据元素
* 除第一个之外，集合中的每一个数据元素均只有一个前驱
* 除最后一个之外，集合的每一个元素均只有一个后继。
## 2.1 线性表的类型表示
* 将线性表记为（a1,...a(i-1),ai,a(i+1),...,an）,其中ai-1领先于ai，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。
* 线性表中元素的个数定义为线性表的长度,n=0时为空表，非空表中的数据元素的位置固定。
* 线性表的长度可以增长和缩短，对表中元素可以访问、插入和删除
## 2.2 线性表的顺序表示和实现
* 顺序表示是指用一组地址连续的存储单元依次存储线性表的数据元素
* 顺序存储结构是一种随机存取的存储模式，只要确定了存储线性表的起始位置，表中的任意数据元素都可以随机存取，不必考虑存储位置，而且存储位置存在着线性关系。
### 线性表的存储结构
```
/* 宏定义 */

#define LIST_INIT_SIZE 100  //线性表存储结构的初始分配量 
#define LISTINCREMENT 10  //分配增量
typedef int LElemType_Sq;

/* 顺序表类型定义 */

typedef  struct
{
	LElemType_Sq *elem;//存储空间的基址，指向第一个结点的指针
	int length;//当前线性表的长度
	int listsize;//当前分配的存储容量	
} SqList;
```
* 以上利用结构体定义了一个顺序表，其中elem指向线性表的基地址。

### 实现基本操作的各种函数
* 初始化函数：先要为顺序表分配一个预定大小的内存空间，而且将length设置为0；
```
//1.初始化操作：为顺序表分配一个预定义大小的数组空间，并将长度设为0； 
int InitList_Sq(SqList *L)   //参数为传入的线性表的首地址 
{
	(*L).elem=(LElemType_Sq *)malloc(sizeof(LElemType_Sq)*LIST_INIT_SIZE);//为顺序表分配空间
	if(!(*L).elem) 
		exit(-1);
	(*L).length=0;//初始化空表长度
	(*L).listsize=100;
	return 0; 
} 
```
* 线性表的插入操作：若下标从0开始，则表中第i个元素为L.elem[i-1]，插入操作即在第i-1和第i个元素之间插入一个元素。首先需要确定插入之后是否会引起内存不够，然后进行内存扩容；之后需要先将i-1之后的元素向后移一位，然后将待插入的元素放入i位置。
```
//10.顺序表中插入一个元素 
int ListInsert_Sq(SqList *L, int i, LElemType_Sq e)
{
	//首先需要判断插入之后表的内存是否够用，若不够用需申请足够的内存
	LElemType_Sq * newbase; 
	if(i<1 || i>(*L).length+1)
		return -1;
	if((*L).length>=(*L).listsize)
	{
		newbase=(LElemType_Sq *)realloc((*L).elem,sizeof(LElemType_Sq)*(LISTINCREMENT+(*L).listsize));
		if(!newbase)
			exit(-1);
		(*L).elem=newbase;
		(*L).listsize+= LISTINCREMENT;
	}
	//开始插入数据元素，需要先把i后面的元素都向后移动一位，然后把e的值赋给当前i位置
	 LElemType_Sq *q;
	 q=&(*L).elem[i-1];//得到待插入位置
     LElemType_Sq *p;  
	for(p=&(*L).elem[(*L).length-1];p>=q;p--)
		*(p+1)=*p;//待插入位置后的元素后移
	*q=e;
	(*L).length++;
	return 0; 
}
```
* 线性表的删除操作：先找到待删除的元素i的位置，然后将i之后的元素向左移一位
```
//11.顺序表删除元素 
int ListDelete_Sq(SqList *L, int i, LElemType_Sq *e)
{
	if(i<1 || i>(*L).length)
		return -1;
	LElemType_Sq *q;
 	q=&(*L).elem[i-1];//得到待插入位置
 	*e=*q;
 	LElemType_Sq *p;
 	p=(*L).elem+(*L).length+1;
 	for(q++;q<=p;q++)
 	{
		*(q-1)=*q; 	
 	}
 	(*L).length--;
 	return 0;
}
```
* 顺序表的合并：将两个顺序表按升序进行合并，变成另外一个链表；一种是利用基本操作函数，另一种利用指针。
* 利用基本操作：同时遍历两个表，得到他们的交集中元素的排列，每得到一个最小值就插入到新表中，直到都插完.(感觉这种方法还是有点问题)
```
void MergeSqList_1(SqList La, SqList Lb, SqList *Lc)
{
	int i,j;
	i=j=1;
	int k=0;
	int len_La,len_Lb;
	LElemType_Sq ai,bj;
	
	InitList_Sq(Lc);
	len_La=ListLength_Sq(La);
	len_Lb=ListLength_Sq(Lb);
	while(i<=len_La && j<=len_Lb)  //扫描La Lb表，扫描完小长度的那个 
	{
		GetElem_Sq(La,i,&ai);  //得到当前表中位置的元素 
		GetElem_Sq(Lb,j,&bj);
		if(ai<=bj)//在当前位置里，若La<Lb，在Lc表中存放La的元素。 
		{
			ListInsert_Sq(Lc,++k,ai);
			i++;//对应的La的位置向前一步			
		}

		else
		{
			ListInsert_Sq(Lc,++k,bj);
			j++;			
		}
	}
	while(i<=len_La)
	{
		GetElem_Sq(La,i++,&ai);
		ListInsert_Sq(Lc,++k,ai);
	}
	
	while(j<=len_Lb)
	{
		GetElem_Sq(Lb,j++,&bj);
		ListInsert_Sq(Lc,++k,bj);
	}	
} 
```
* 利用指针。得到两个表的首地址和尾地址。然后进行循环，最终插入新表。
```
void MergeSqList_2(SqList La, SqList Lb, SqList *Lc)
{
	LElemType_Sq *pa, *pb, *pc;
	LElemType_Sq *pa_last, *pb_last;
		
	pa = La.elem;						//指向La第一个元素 
	pb = Lb.elem;						//指向Lb第一个元素
	
										//不用InitList_Sq创建Lc 
	(*Lc).listsize = (*Lc).length = La.length + Lb.length;
	pc = (*Lc).elem = (LElemType_Sq *)malloc((*Lc).listsize*sizeof(LElemType_Sq));
	if(!pc) 
		exit(OVERFLOW);
	
	pa_last = La.elem + La.length - 1;	//指向La最后一个元素
	pb_last = Lb.elem + Lb.length - 1;	//指向Lb最后一个元素
	
	while(pa<=pa_last && pb<=pb_last) 	//La和Lb均未扫描完 
	{
		if(*pa <= *pb)
			*pc++ = *pa++;
		else
			*pc++ = *pb++;
	}
	
	while(pa <= pa_last)				//表La未扫描完 
		*pc++ = *pa++;					//插入La的剩余元素

	while(pb <= pb_last)				//表Lb未扫描完
		*pc++ = *pb++;					//插入Lb的剩余元素
}
```

## 2.3 线性表的链式表示和实现
* 定义：用一组任意存储单元存储线性表的数据元素，存储单元可以连续，也可以不连续。对数据元素来说，除了存储本身的信息之外，还需要存储一个指示其后继的信息。即包括两个域：数据域和指针域。每个结点中只包含了一个指针域，又称单链表。
```
typedef int LElemType_L; //定义数据元素类型 
typedef struct LNode
{
	LElemType_L data;  //数据域 
	struct LNode* next;	//指针域 
}LNode;

typedef LNode* LinkList;  //指向单链表结点的指针
```
* 若L是LinkList的变量，则L为单链表的头指针，指向表中第一个结点，L=null，表示该表为空。
### 单链表的基本操作函数
* 得到单链表中i位置的元素:与顺序表不同，单链表要获得某一位置的元素，需要依次遍历才能得到，需要注意的是，遍历要从第一个结点开始,而非头结点。因此，p=L->next。
```
//6.得到单链表中i位置的元素 
int GetElem_L(LinkList L, int i, LElemType_L *e)
{
	int j;
	LinkList p;
	j=0;
	p=L->next;
	
	while(p && j<i)//得到i位置的地址和j值 
	{
		j++;
		p=p->next;
	}
	
	if(!p ||j>i)
		return 0;
	
	(*e)=p->data;
	return 1;		
}
```
* 单链表的插入操作：与顺序表相比，单链表的插入要简单的多，先申请一个新插入结点的内存，然后将其前驱的指针域传给新结点的指针域，指向后一个结点，然后把新结点的地址传给前驱的指针域。
```
//10.单链表的插入操作 
int ListInsert_L(LinkList L, int i, LElemType_L e)
{
	LinkList p,s;
	int j;
	p=L;
	j=0;
	
	while(p && j<i-1)
	{
		p=p->next;
		++j;//最后一个不++，得到i-1 
	}	
	if(!p  || j>i-1)
	{
		return 0;
	}
	
	s=(LinkList)malloc(sizeof(LNode));
	if(!s)
		return 0;
	s->data=e;
	s->next=p->next;
	p->next=s;
	
	return 1;
} 
```
* 单链表的删除操作：删除操作相对更加简单，只需要将待删除结点的指针域传给其前驱的指针域。然后将待删除结点的内存销毁即可。
```
//11.单链表的删除操作 
int ListDelete_L(LinkList L, int i, LElemType_L *e)
{
	LinkList pre,p;
	int j;
	
	pre=L;
	j=1;
	while(pre->next  &&j<i)//找到i的位置，并将pre指向i元素的前驱
	{
		pre=pre->next;
		++j;	
	} 
	if(!pre->next || j>i)
		return 0;
	p=pre->next;
	(*e)=p->data;
	pre->next=p->next;
	free(p);
	return 1;
}
```
* 头插法创建链表：不断的把新结点插入到头结点的后面，把一前插入的元素往后移。因此也是逆序插入。要点是把新插入结点的地址传给头结点的指针域，它自然指向的是第一个结点，因此每次新插入的都会变成第一个结点
```
//13.头插法建立单链表（逆序输入） 
int CreateList_HL(FILE *fp, LinkList *L, int n)
{
	LinkList p;
	LElemType_L tmp;
	int i;
	
	*L=(LinkList)malloc(sizeof(LNode));
	if(!(*L))
		return 0;
	(*L)->next=NULL;  //建立头结点
	
	for(i=1;i<=n;i++)
	{
		if(Scanf(fp,"%d",&tmp)==1)
		{
			p=(LinkList)malloc(sizeof(LNode));
		if(!p)
			return 0;
		p->data=tmp;
		p->next=(*L)->next;
		(*L)->next=p;
		}
		else
			return 0;
		
	} 
	return 1;		
} 
```
* 尾插法创建链表：结点依次一个一个的被创建，新结点被创建在链表的尾部。
```
int CreateList_TL(FILE *fp, LinkList *L, int n)
{
	int i;
	LinkList p,q;
	LElemType_L tmp;
	*L=(LinkList)malloc(sizeof(LNode));
	if(!(*L))
		return 0;
	(*L)->next=NULL;
	
	for(i=1,q=*L;i<=n;i++)
	{
		if(Scanf(fp,"%d",&tmp)==1)
		{
			p=(LinkList)malloc(sizeof(LNode));
			if(!p)
				return 0;
			p->data=tmp;
			q->next=p;
			q=q->next;	
		}
		else
			return 0;
	}
	return 1;
}
```








