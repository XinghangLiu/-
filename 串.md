# 4 串
## 4.1 定义
* 串是由零个或多个字符组成的有限序列，一般记为s='a1a2a3....'，其中，s为串的名称，用单引号括起来的是串的值。串中任意个连续字符组成的子序列称为子串，包含字串的串相应的被称为主串。
* 在串的操作集中，有串赋值，串比较，求串长，串连接，求子串   5种最小操作子集。
## 4.2 实现
### 4.2.1 定长顺序存储表示
* 用数组来表示字符串
```
#define MAXSTRLEN 255
typedef unsigned char SString[MAXSTRLEN+1];   //0号单元存放串的长度
```
* 基本操作函数
```
/*基本操作函数*/
//1.生成一个其值为常量chars的字符串     串赋值 
int StrAssign_Sq(SString T, const char *chars)
{
	int i,len;
	len=strlen(chars);
	if(len>MAXSTRLEN)
		return 0;
	else
	{
		T[0]=len;
		for(i=1;i<=T[0];i++)
		{
			T[i]=chars[i-1];
		}
		return 1;	
	}		
}
//2.串复制 
void StrCopy_Sq(SString T, SString S)
{
	int i;
	for(i=0;i<=S[0];i++)
	{
		T[i]=S[i];
	}
}
//3.判空
int StrEmpty_Sq(SString S)
{
	if(S[0]==0)
	{
		return 1;
	}
	else
	{
		return 0;
	}
} 
//4.比较
int StrCompare_Sq(SString S, SString T)  //最小操作子集 
{
	int i=1;
	while(i<=S[0] && i<=T[0])   
	{
		if(S[i]==T[i])  //如果字符相同，比较下一位 
			i++;
		else
			return S[i]-T[i];  //发现不同字符，字符大的大。 
	}
	return S[0]-T[0]; //最终以长度来比较 
} 
//5.串长 
int StrLength_Sq(SString S)  //最小操作子集 
{
	return S[0];
} 
//6.清空S 
void ClearString_Sq(SString S)
{
	S[0]=0; 
} 
//7.T返回s1和s2链接的新串 
int Concat_Sq(SString T, SString S1, SString S2)
{
	int i;
	for(i=1;i<=S1[0];i++)
		T[i]=S1[i];
	if(S1[0]+S2[0]<=MAXSTRLEN)
	{
		for(i=1;i<=S2[0];i++)
		{
			T[S1[0]+i]=S2[i];
		}
		T[0]=S1[0]+S2[0];
		return 1;
	}
	else
	{
		for(i=1;S1[0]+i<=MAXSTRLEN;i++)
		{
			T[S1[0]+i]=S2[i];
		}
		T[0]=MAXSTRLEN;
		return 0;
	}
}
//8.用sub返回从第pos起，长度为len的子串 
int SubString_Sq(SString Sub, SString S, int pos, int len)  //最小操作集 
{
	int i;
	if(pos<1 || pos>S[0]  || len<0 || pos+len-1>S[0])
		return 0;
	
	for(i=1;i<=len;i++)
	{
		Sub[i]=S[pos+i-1];
	}
	Sub[0]=len;
	return 1;
}
//9.1.返回T在S中第pos个字符后第一次出现的位置，不存在则返回0 (用到最小操作集)
int Index_Sq_1(SString S, SString T, int pos)
{
	int s,t;
	SString Sub;
	
	if(pos>0)
	{
		s=StrLength_Sq(S);  
		t=StrLength_Sq(T);
		if(s && t)  //如果长度都不为0 
		{
			while(pos+t-1<=s)  //如果s中字符出现的位置+t小于s....就是能狗遍历到整个t，进入循环 
			{
				SubString_Sq(Sub,S,pos,t);//先得到从pos开始，大小为t的s的子串 
				if(!StrCompare_Sq(Sub,T))//判断，如果这个字串和T不相同了 ，返回 
					return pos;
				pos++;
			}
		}
	}
	return 0;
}
//9.2.返回T在S中第pos个字符后第一次出现的位置，不存在则返回0 (没用到最小操作集)
int Index_Sq_2(SString S, SString T, int pos)
{
	int i=pos;
	int j=1;
	if(pos<1)
		return 0;
	
	while(i<=S[0] && j<=T[0])
	{
		if(S[i]==T[j])	
		{
			i++;
			j++;
		}
		else
		{
			i=i-(j-1)+1;  //j-1表示i白白的走了j-1步 
			j=1;
		}
	}
	if(j>T[0] &&T[0])
	{
		return i-T[0];
	}
	else
		return 0;
} 
//10.用V替换主串S中出现的所有与T相等的不重叠的子串，可以被完全替换才返回OK。
int Replace_Sq(SString S, SString T, SString V)
{
	int i;
	i=Index_Sq_2(S,T,1);//寻找第一个匹配的位置
	while(S[0]-T[0]+V[0]<=MAXSTRLEN && i)
	{
		StrDelete_Sq(S,i,T[0]);
		StrInsert_Sq(S,i,V);
		i+=V[0];  //i切换到下一个位置。
		i=Index_Sq_2(S,T,i); 
	} 
	if(i=0)
		return 1;
	else
		return 0;
}
//11.在串S的第pos个字符之前插入串T。可以完全插入返回OK,否则返回ERROR
int StrInsert_Sq(SString S, int pos, SString T)
{
	int i;
	if(pos<1 ||pos>S[0]+1 || S[0]+T[0]>MAXSTRLEN)
		return 0;
	for(i=S[0];i>=pos;i--)
	{
		S[i+T[0]]=S[i];	
	} 
	for(i=pos;i<=pos+T[0]-1;i++)
	{
		S[i]=T[i-pos+1];
	}
	S[0]+=T[0];
	return 1;
} 
//12.从串S中删除第pos个字符起长度为len的子串
int StrDelete_Sq(SString S, int pos, int len)
{
	int i;
	if(pos<0 ||pos+len-1>S[0] ||len<0)
		return 0;
	for(i=pos+len;i<=S[0];i++)
	{
		S[i-len]=S[i];
	}
	S[0]-=len;
	return 1;
}
//13.输出字符串
void StrPrint_Sq(SString S)
{
	int i;
	for(i=1;i<=S[0];i++)
	{
		printf("%c",S[i]);
	}
} 
```
## 4.2.2 堆分配存储表示
* 定义：以一组地址连续的存储单元来存放串值字符序列，但其空间是动态分配的。即堆的存储，利用malloc函数来管理。
