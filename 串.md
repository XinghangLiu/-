# 4 串
## 4.1 定义
* 串是由零个或多个字符组成的有限序列，一般记为s='a1a2a3....'，其中，s为串的名称，用单引号括起来的是串的值。串中任意个连续字符组成的子序列称为子串，包含字串的串相应的被称为主串。
* 在串的操作集中，有串赋值，串比较，求串长，串连接，求子串   5种最小操作子集。
## 4.2 实现
### 4.2.1 定长顺序存储表示
* 用数组来表示字符串
```
#define MAXSTRLEN 255
typedef unsigned char SString[MAXSTRLEN+1];   //0号单元存放串的长度
```
* 基本操作函数
```
/*基本操作函数*/
//1.生成一个其值为常量chars的字符串     串赋值 
int StrAssign_Sq(SString T, const char *chars)
{
	int i,len;
	len=strlen(chars);
	if(len>MAXSTRLEN)
		return 0;
	else
	{
		T[0]=len;
		for(i=1;i<=T[0];i++)
		{
			T[i]=chars[i-1];
		}
		return 1;	
	}		
}
//2.串复制 
void StrCopy_Sq(SString T, SString S)
{
	int i;
	for(i=0;i<=S[0];i++)
	{
		T[i]=S[i];
	}
}
//3.判空
int StrEmpty_Sq(SString S)
{
	if(S[0]==0)
	{
		return 1;
	}
	else
	{
		return 0;
	}
} 
//4.比较
int StrCompare_Sq(SString S, SString T)  //最小操作子集 
{
	int i=1;
	while(i<=S[0] && i<=T[0])   
	{
		if(S[i]==T[i])  //如果字符相同，比较下一位 
			i++;
		else
			return S[i]-T[i];  //发现不同字符，字符大的大。 
	}
	return S[0]-T[0]; //最终以长度来比较 
} 
//5.串长 
int StrLength_Sq(SString S)  //最小操作子集 
{
	return S[0];
} 
//6.清空S 
void ClearString_Sq(SString S)
{
	S[0]=0; 
} 
//7.T返回s1和s2链接的新串 
int Concat_Sq(SString T, SString S1, SString S2)
{
	int i;
	for(i=1;i<=S1[0];i++)
		T[i]=S1[i];
	if(S1[0]+S2[0]<=MAXSTRLEN)
	{
		for(i=1;i<=S2[0];i++)
		{
			T[S1[0]+i]=S2[i];
		}
		T[0]=S1[0]+S2[0];
		return 1;
	}
	else
	{
		for(i=1;S1[0]+i<=MAXSTRLEN;i++)
		{
			T[S1[0]+i]=S2[i];
		}
		T[0]=MAXSTRLEN;
		return 0;
	}
}
//8.用sub返回从第pos起，长度为len的子串 
int SubString_Sq(SString Sub, SString S, int pos, int len)  //最小操作集 
{
	int i;
	if(pos<1 || pos>S[0]  || len<0 || pos+len-1>S[0])
		return 0;
	
	for(i=1;i<=len;i++)
	{
		Sub[i]=S[pos+i-1];
	}
	Sub[0]=len;
	return 1;
}
//9.1.返回T在S中第pos个字符后第一次出现的位置，不存在则返回0 (用到最小操作集)
int Index_Sq_1(SString S, SString T, int pos)
{
	int s,t;
	SString Sub;
	
	if(pos>0)
	{
		s=StrLength_Sq(S);  
		t=StrLength_Sq(T);
		if(s && t)  //如果长度都不为0 
		{
			while(pos+t-1<=s)  //如果s中字符出现的位置+t小于s....就是能狗遍历到整个t，进入循环 
			{
				SubString_Sq(Sub,S,pos,t);//先得到从pos开始，大小为t的s的子串 
				if(!StrCompare_Sq(Sub,T))//判断，如果这个字串和T不相同了 ，返回 
					return pos;
				pos++;
			}
		}
	}
	return 0;
}
//9.2.返回T在S中第pos个字符后第一次出现的位置，不存在则返回0 (没用到最小操作集)
int Index_Sq_2(SString S, SString T, int pos)
{
	int i=pos;
	int j=1;
	if(pos<1)
		return 0;
	
	while(i<=S[0] && j<=T[0])
	{
		if(S[i]==T[j])	
		{
			i++;
			j++;
		}
		else
		{
			i=i-(j-1)+1;  //j-1表示i白白的走了j-1步 
			j=1;
		}
	}
	if(j>T[0] &&T[0])
	{
		return i-T[0];
	}
	else
		return 0;
} 
//10.用V替换主串S中出现的所有与T相等的不重叠的子串，可以被完全替换才返回OK。
int Replace_Sq(SString S, SString T, SString V)
{
	int i;
	i=Index_Sq_2(S,T,1);//寻找第一个匹配的位置
	while(S[0]-T[0]+V[0]<=MAXSTRLEN && i)
	{
		StrDelete_Sq(S,i,T[0]);
		StrInsert_Sq(S,i,V);
		i+=V[0];  //i切换到下一个位置。
		i=Index_Sq_2(S,T,i); 
	} 
	if(i=0)
		return 1;
	else
		return 0;
}
//11.在串S的第pos个字符之前插入串T。可以完全插入返回OK,否则返回ERROR
int StrInsert_Sq(SString S, int pos, SString T)
{
	int i;
	if(pos<1 ||pos>S[0]+1 || S[0]+T[0]>MAXSTRLEN)
		return 0;
	for(i=S[0];i>=pos;i--)
	{
		S[i+T[0]]=S[i];	
	} 
	for(i=pos;i<=pos+T[0]-1;i++)
	{
		S[i]=T[i-pos+1];
	}
	S[0]+=T[0];
	return 1;
} 
//12.从串S中删除第pos个字符起长度为len的子串
int StrDelete_Sq(SString S, int pos, int len)
{
	int i;
	if(pos<0 ||pos+len-1>S[0] ||len<0)
		return 0;
	for(i=pos+len;i<=S[0];i++)
	{
		S[i-len]=S[i];
	}
	S[0]-=len;
	return 1;
}
//13.输出字符串
void StrPrint_Sq(SString S)
{
	int i;
	for(i=1;i<=S[0];i++)
	{
		printf("%c",S[i]);
	}
} 
```
## 4.2.2 堆分配存储表示
* 定义：以一组地址连续的存储单元来存放串值字符序列，但其空间是动态分配的。即堆的存储，利用malloc函数来管理。其比起定长顺序的串，优点在于它可以动态改变串的长度，在串合并或者删除时，可以避免发生截断的情况，避免信息流失。
* 类型定义
```
/*堆串类型的定义*/
typedef struct
{
	char * ch;
	int len;
}HString;
```
* 基本操作函数
```
/*HeapString.c*/
#include "HeapString.h"

/*基本操作函数*/
//1.初始化 
void InitString_H(HString *S)
{
	(*S).ch=NULL;
	(*S).len=0;
}
//2.串赋值
int StrAssign_H(HString *T, char *chars)
{
	int i,j;
	InitString_H(T);
	i=strlen(chars);
	if(!i)
	{
		return 0;
	}
	else
	{
		(*T).ch=(char *)malloc(sizeof(char)*i);
		if(!(*T).ch)
		{
			exit(-1);
		}
		for(j=0;j<i;j++)
			(*T).ch[j]=chars[j];
		(*T).len=i;
	}
	return 1;
} 
//3.串复制
int StrCopy_H(HString *T, HString S)
{
	int i;
	InitString_H(T);
	if(StrEmpty_H(S))
		return 0;
	(*T).ch=(char*)malloc(S.len*sizeof(char));
	if(!(*T).ch)
		exit(-1);
	for(i=0;i<S.len;i++)
	{
		(*T).ch[i]=S.ch[i];
	}
	(*T).len=S.len;
	return 1;
} 
//4.判空
int StrEmpty_H(HString S)
{
	if(S.len==0 && S.ch==NULL)
	{
		return 1;
	}
	else
	{
		return 0;
	}
} 
//5.比较两个字符串的大小
int StrCompare_H(HString S, HString T)
{
	int i;
	for(i=0;i<S.len && i<T.len;i++)
	{
		if(S.ch[i]!=T.ch[i])
			return S.ch[i]-T.ch[i];	
	}
	return S.len-T.len;
} 
//6.求串长
int StrLength_H(HString S)
{
	return S.len;
}
//7.清空
int ClearString_H(HString *S)
{
	if((*S).ch)
	{
		free((*S).ch);
		(*S).ch=NULL;
	}
	(*S).len=0;
	return 1;
} 
//8.T是有S1和S2串联起来的 
int Concat_H(HString *T, HString S1, HString S2)
{
	InitString_H(T);
	(*T).len=S1.len+S2.len;
	(*T).ch=(char *)malloc((*T).len*sizeof(char));
	if(!(*T).ch)
		exit(-1);
	int i;
	for(i=0;i<S1.len;i++)
	{
		(*T).ch[i]=S1.ch[i];
	}
	for(i=0;i<S2.len;i++)
	{
		(*T).ch[S1.len+i]=S2.ch[i];
	}
	return 1;
}
//9.用Sub返回串S的第pos个字符起长度为len的子串
int SubString_H(HString *Sub, HString S, int pos, int len)
{
	InitString_H(Sub);
	if(StrEmpty_H(S))
		return 0;
	if(pos<1 || pos> S.len ||len<0 ||pos+len-1> S.len)
		return 0;
	
	(*Sub).ch=(char*)malloc(sizeof(char)*len);
	if(!(*Sub).ch)
		exit(-1);
	int i;
	for(i=0;i<len;i++)
		(*Sub).ch[i]=S.ch[pos+i-1];
	(*Sub).len=len;
	return 1;
}
//10.返回T在S中第pos个字符后第一次出现的位置，不存在则返回0。
int Index_H(HString S, HString T, int pos)
{
	int s,t,i;
	HString Sub;
	InitString_H(&Sub);
	if(pos>0)
	{
		s=S.len;
		t=T.len;
		i=pos;
		while(i+t-1<=s)
		{
			SubString_H(&Sub,S,i,t);
			if(StrCompare_H(Sub,T))
				i++;
			else
				return i;
		}	
	}
	return 0;
}
//11.用V替换主串S中出现的所有与T相等的不重叠的子串
int Replace_H(HString *S, HString T, HString V)
{
	int i;
	if(StrEmpty_H(T))
		return 0;
	i=Index_H(*S,T,1);
	while(i!=0)
	{
		StrDelete_H(S,i,StrLength_H(T));
		StrInsert_H(S,i,V);
		i+=StrLength_H(V);
		i=Index_H(*S,T,i);
	}
	return 1;
}
//12.在串S的第pos个字符之前插入串T
int StrInsert_H(HString *S, int pos, HString T)
{
	int i;
	if(pos<1 ||pos>(*S).len+1 )
		return 0;
	if(StrEmpty_H(T))
		return 0;
	else
	{
		(*S).ch=(char*)realloc((*S).ch,sizeof(char)*((*S).len+T.len));
		if(!(*S).ch)
			exit(-1);
		for(i=(*S).len-1;i>=pos-1;i--)
		{
			(*S).ch[i+T.len]=(*S).ch[i];
		}
		for(i=0;i<T.len;i++)
		{
			(*S).ch[pos+i-1]=T.ch[i];
		}
		(*S).len+=T.len;
	}
	return 1;
}
//13.从串S中删除第pos个字符起长度为len的子串
int StrDelete_H(HString *S, int pos, int len)
{
	int i;
	if(StrEmpty_H(*S))
		return 0;
	if(pos<1 ||pos+len-1>(*S).len ||len<0)
	{
		return 0;
	}
	for(i=pos-1;i+len<=(*S).len;i++)
	{
		(*S).ch[i]=(*S).ch[i+len];	
	}
	(*S).len-=len;
	(*S).ch=(char*)malloc(sizeof(char)*(*S).len);
	return 1;
}
//14.销毁串S 
void DestroyString_H(HString *S)
{
	//堆串不能销毁。 
}
//15.串输出
void StrPrint_H(HString S)
{
	int i;
	if(StrEmpty_H(S))
		printf("S为空串，不可输出！");
		
	for(i=0;i<S.len;i++)
	{
		printf("%c",S.ch[i]);
	}
} 
```
